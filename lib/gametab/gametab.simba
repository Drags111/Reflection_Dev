const
  INTERFACE_HITPOINTS = 748;
  INTERFACE_PRAYER = 749;
  INTERFACE_RUN = 750;

const
  SETTING_RUN = 173;

{*******************************************************************************
function R_WorldMapOpen : Boolean;
Description: Returns true if world map is open
******************************************************************************* }
function R_WorldMapOpen : Boolean;
var
  Map: TRSChild;
begin
  Result := R_ValidInterface(755);
  if not Result then
    Exit;
  Map := R_GetRSChild(755, 0);
  Result := (Map.Width <> 0);
end;

{*******************************************************************************
function R_CloseWorldMap : Boolean;
By: Drags111
Description: Closes map.
******************************************************************************* }
function R_CloseWorldMap : Boolean;
var
  T, I: Integer;
  Btn: TRSChild;
begin
  Result := False;
  if not R_LoggedIn then Exit;
  if not R_WorldMapOpen then
  begin
    Result := True;
    Exit;
  end;

  Btn := R_GetRSChild(755, 44);
  R_MouseChild(Btn, 1);

  for I := 0 to 1 do
  begin
    MarkTime(T);
    while(R_WorldMapOpen)do
    begin
      wait(50+Random(50));
      if(TimeFromMark(t) > 5000)then
      begin
        R_Debug('Timed out closing World Map', 'R_CloseWorldMap');
        Exit;
      end;
    end;
    Result := not R_WorldMapOpen;
  end;
end;

{*******************************************************************************
function R_GetMMLevels(Which: string): Integer;
By: lordsaturn and Drags111
Description: Returns the current value at the designated MM spot.
*******************************************************************************}
function R_GetMMLevels(Which: string): Integer;
begin
  Result := -1;
  case LowerCase(Which) of
    'hitpoints', 'hp', 'lp', 'lifepoints': Result := StrToInt(R_GetInterfaceText(INTERFACE_HITPOINTS, 8));
    'prayer', 'pp'   : Result := StrToInt(R_GetInterfaceText(INTERFACE_PRAYER, 4));
    'run', 'energy'  : Result := StrToInt(R_GetInterfaceText(INTERFACE_RUN, 5));
    else R_Debug('R_GetMMLevels', 'Invaild string.');
  end;
end;

{*******************************************************************************
function R_IsRunning: boolean;
By: Drags111
Description: Returns true if the run option is set to true.
*******************************************************************************}
function R_IsRunning: boolean;
begin
  Result := R_GetSetting(SETTING_RUN) = 1;
end;

{*******************************************************************************
function R_IsResting: boolean;
By: Drags111
Description: Returns true if your player is performing the resting animation.
*******************************************************************************}
function R_IsResting: boolean;
var
  Animations: TIntegerArray;
begin
  SetLength(Animations, 5);
  Animations := [12108, 2033, 2716, 11786, 5713];
  Result := InIntArray(Animations, R_GetAnimation);
end;

{*******************************************************************************
function R_Rest(MaxEnergy: integer): boolean;
By: Drags111
Description: Uses the rest ability until the desired energy is reached.
*******************************************************************************}
function R_Rest(MaxEnergy: integer): boolean;
var
  T, MT, Energy: integer;
  RunIcon: TRSChild;
begin
  Result := True;
  MarkTime(mt);
  Energy := R_GetMMLevels('Run');
  if(Energy >= MaxEnergy)then
    Exit;
  Result := R_IsResting;
  while(not Result)do
  begin
    if not LoggedIn or (TimeFromMark(MT) > 9000)then
      Exit;
    RunIcon := R_GetRSChild(INTERFACE_RUN, 1);
    R_MouseChild(RunIcon, 2);
    Result := R_ChooseOption('Rest');
    if(Result)then
    begin
      MarkTime(T);
      While((not R_IsResting) and (TimeFromMark(T) < 3000))do
        wait(100+Random(100));
      Result := (R_IsResting);
    end;
  end;
  Energy := R_GetMMLevels('run');
  while(Energy < MaxEnergy)do
  begin
    case Random(50) of
      0..5: SleepAndMoveMouse(Random(1000));
      else wait(100+Random(400));
    end;
    Energy := R_GetMMLevels('run');
  end;
end;

{*******************************************************************************
function _SkillStringToInt(skill: string): Integer;
By: Nava2
Description: Gets the integer index of a skill string name.
*******************************************************************************}
function R_SkillStringToInt(skill: string): Integer;
var
  i, h: Integer;
begin
  Result := -1;
  skill := LowerCase(skill);
  h := High(SKILL_STRINGS);
  for i := 0 to h do
    if (skill = SKILL_STRINGS[i]) then
    begin
      Result := i;
      Exit;
    end;

  SRL_Warn('_SkillStringToInt',
           'skill: ' + skill + ' was not valid.',
           warn_AllVersions);
end;

{*******************************************************************************
function R_GetSkillLevel(skill: variant): Integer;
By: Nava2
Description: Gets the Level stored at skill. Skill can be the string or const.
             The const is significantly faster.
*******************************************************************************}
function R_GetSkillLevel(skill: variant): Integer;
var
  Index: Integer;
begin
  case VarType(skill) of
    varString: Index := R_SkillStringToInt(skill);
    varInteger: Index := skill;
    else
      SRL_Warn('GetSkillLevel', 'Invalid var type passed.', warn_AllVersions);
  end;

  Result := SmartGetFieldArrayInt(0, hook_static_GetSkillLevels, Index);
end;

{*******************************************************************************
function R_GetSkillExperience(skill: variant): Integer;
By: Nava2
Description: Gets the Experience stored at skill. Skill can be the string or
             const. The const is significantly faster.
*******************************************************************************}
function R_GetSkillExperience(skill: variant): Integer;
var
  Index: Integer;
begin
  case VarType(skill) of
    varString: Index := R_SkillStringToInt(skill);
    varInteger: Index := skill;
    else
      SRL_Warn('GetSkillLevel', 'Invalid var type passed.', warn_AllVersions);
  end;

  Result := SmartGetFieldArrayInt(0, hook_static_GetSkillExperiences, Index);
end;

{*******************************************************************************
function R_ExpToNextLevel(skill: variant): Integer;
By: Shuttleu
Description: Gets the Experience needed to get to the next level
*******************************************************************************}
function R_ExpToNextLevel(Skill: variant): Integer;
var
  Level, i, Index: Integer;
begin
  case VarType(skill) of
    varString: Index := R_SkillStringToInt(skill);
    varInteger: Index := skill;
    else
      SRL_Warn('GetSkillLevel', 'Invalid var type passed.', warn_AllVersions);
  end;
  Level:= SmartGetFieldArrayInt(0, hook_static_GetSkillLevels, Index);
  Result:= 0;
  for i := 1 to Level do
    Result := Result + floor(i + 300 * Pow(2.0, i / 7.0));
  Result:= (Result/4) - SmartGetFieldArrayInt(0, hook_static_GetSkillExperiences, Index);
end;
