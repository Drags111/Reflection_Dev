{*
Menu
====

All routines related to the menu option selectings.

*}

(*
R_GetMenuItems
~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_GetMenuItems: TStringArray;

Returns a string array of all of the options in a non-tabbed menu.

.. note::

  by Drags111/Pyroryan

*)
function R_GetMenuItems: TStringArray;
var
  Option, Action, Count, I: Integer;
  NodeList, MenuItemNode, Last, Tail: Integer;
  Item: String;
  Temp, ItemList: TStringArray;
begin
  try
    NodeList := Client.MenuNodeList();
    MenuItemNode := R_GetNodeHead(NodeList);

    while(MenuItemNode <> 0)do
    begin
      Action := SmartGetFieldObject(MenuItemNode, hook_menu_Action);
      Option := SmartGetFieldObject(MenuItemNode, hook_menu_Option);

      if(Action = 0) or (Option = 0)then
      begin
        R_FreeObjects([Action, Option]);
        break;
      end;

      Item := Trim(R_GetJavaString(Action, 256) + ' ' +
                   R_GetJavaString(Option, 256));
      R_FreeObjects([Action, Option]);
      SetLength(ItemList, Length(ItemList)+1);
      ItemList[High(ItemList)] := R_TrimHTML(Item);

      Last := MenuItemNode;
      MenuItemNode := R_GetNodeNext(Last);

      R_FreeObject(Last);
    end;

  finally
    R_FreeObjects([MenuItemNode, NodeList, Action, Option, Last, Tail]);
  end;

  //Have to reverse the array because it loads up backwards...
  Count := 0;
  SetLength(Temp, Length(ItemList));
  for I := 0 to High(ItemList)do
    Temp[I] := ItemList[I];
  for I := High(Temp) downto 0 do
  begin
    ItemList[Count] := R_TrimHTML(Trim(Lowercase(Temp[I])));
    Inc(Count);
  end;
  Result := ItemList;
end;

(*
R_GetMenuItemsTabbed
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_GetMenuItemsTabbed: array of TStringArray;

Returns a  2-dimensional string array of all of the options in a tabbed menu.

.. note::

  by Drags111/Pyroryan

*)
function R_GetMenuItemsTabbed: array of TStringArray;
var
  Action, Option, Name: Integer;
  NodeSubList, GroupNode: Integer;
  SubMenu, MenuItemNode, Last, Last2: Integer;
  Item: String;
  Items: TStringArray;
begin
  try
    NodeSubList := Client.CollapsedMenuItems();
    GroupNode := R_GetNodeSubHead(NodeSubList);

    while(GroupNode <> 0)do
    begin
      SubMenu := SmartGetFieldObject(GroupNode, hook_MenuGroupNode_GetNodeSubListItems);
      if (SubMenu <= 0) then
        break;

      MenuItemNode := R_GetNodeSubHead(SubMenu);

      while (MenuItemNode <> 0) do
      begin

        Action := SmartGetFieldObject(menuItemNode, hook_menu_Action);
        Option := SmartGetFieldObject(menuItemNode, hook_menu_Option);

        if(Action = 0) and (Option = 0)then
        begin
          R_FreeObjects([Action, Option]);
          break;
        end;

        Item := Trim(R_GetJavaString(Action, 512) + ' ' +
                     R_GetJavaString(Option, 512));
        R_FreeObjects([Action, Option]);
        SetLength(Items, Length(Items)+1);
        Items[High(Items)] := Trim(R_TrimHTML(Lowercase(Item)));

        Last2 := MenuItemNode;
        MenuItemNode := R_GetNodeSubNext(Last2);

        R_FreeObject(Last2);
      end;

      if(Length(Items) > 0)then
      begin
        SetLength(Result, Length(Result)+1);
        Result[High(Result)] := Items;
        SetLength(Items, 0);
      end;

      Last := GroupNode;
      GroupNode := R_GetNodeSubNext(Last);

      R_FreeObjects([Last, SubMenu, MenuItemNode]);
    end;
  finally
    R_FreeObjects([GroupNode, NodeSubList, SubMenu, MenuItemNode,
                   Action, Option, Last, Last2]);
  end;
end;

(*
R_MMouseMenu
~~~~~~~~~~~~

.. code-block:: pascal

    function R_MMouseMenu(Options: TStringArray): Boolean;

Moves the mouse over the first instance of the options provided. Used in
R_ChooseOptionMulti.

.. note::

  by Drags111

*)
function R_MMouseMenu(Options: TStringArray): Boolean;
var
  MenuItems: TStringArray;
  I, L, X, Y, MX, MY, MW, MH, xOff, yOff: Integer;
  Option: String;
  Dimensions: TBox;
begin
  Result := False;
  if not Client.MenuOpen() then
    Exit;
  MX := Client.MenuX();
  MY := Client.MenuY();
  MW := Client.MenuWidth();
  MH := Client.MenuHeight();

  MenuItems := R_GetMenuItems;

  for I := 0 to High(MenuItems)do
    for L := 0 to High(Options)do
      if(Pos(Trim(Lowercase(Options[L])), MenuItems[I]) > 0)then
      begin
        Option := MenuItems[I];
        xOff := RandomRange(0, 4 + Random(Length(Option) * 4 - 4));
        yOff := 21 + (16 * I) + RandomRange(2, 10);
        MMouse(MX + xOff, MY + yOff, 0, 0);

        GetMousePos(X, Y);
        Dimensions := IntToBox(MX, MY, MX + MW, MY + MH);
        if(Client.MenuOpen() and PointInBox(Point(X, Y), Dimensions))then
        begin
          Result := true;
          Exit;
        end else
          MMouse(MX - 10, MY - 10, 3, 3);
      end;
end;

(*
R_MMouseMenuTabbed
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_MMouseMenuTabbed(Options: TStringArray): Boolean;

Moves the mouse over the first instance of the options provided. Used in
R_ChooseOptionMulti.

.. note::

  by Drags111

*)
function R_MMouseMenuTabbed(Options: TStringArray): Boolean;
var
  MenuItems: array of TStringArray;
  I, K, L, X, Y, MX, MY, MW, MH, xOff, yOff: Integer;
  Option: String;
  Dimensions: TBox;
begin
  Result := False;
  if(not Client.MenuOpen()) or (not Client.IsMenuTabbed())then
    Exit;

  MenuItems := R_GetMenuItemsTabbed;

  for I := 0 to High(MenuItems)do
    for K := 0 to High(MenuItems[I])do
      for L := 0 to High(Options)do
        if(Pos(Trim(Lowercase(Options[L])), MenuItems[I][K]) > 0)then
        begin
          if not Client.MenuOpen() then
            Exit;
          MX := Client.MenuX();
          MY := Client.MenuY();
          MW := Client.MenuWidth();
          MH := Client.MenuHeight();

          Option := MenuItems[I][K];
          xOff := RandomRange(0, 4 + Random(Length(Option) * 4 - 4));
          yOff := 21 + (16 * I) + RandomRange(2, 10);
          MMouse(MX + xOff, MY + yOff, 0, 0);
          GetMousePos(X, Y);
          Dimensions := IntToBox(MX, MY, MX + MW, MY + MH);
          if not Client.MenuOpen() or not PointInBox(Point(X, Y), Dimensions)then
            Exit;
          wait(100+Random(1000));

          MX := Client.MenuX2();
          MY := Client.MenuY2();
          MW := Client.MenuWidth2();
          MH := Client.MenuHeight2();

          xOff := RandomRange(0, 10);
          MMouse(MX + xOff, Y, 0, 2);
          wait(100+Random(100));
          xOff := RandomRange(0, 4 + Random(Length(Option) * 4 - 4));
          yOff := 21 + (16 * K) + RandomRange(2, 10);
          MMouse(MX + xOff, MY + yOff, 0, 0);
          GetMousePos(X, Y);
          Dimensions := IntToBox(MX, MY, MX + MW, MY + MH);

          if(Client.MenuOpen() and PointInBox(Point(X, Y), Dimensions))then
          begin
            Result := True;
            Exit;
          end else
          begin
            MX := Client.MenuX();
            MY := Client.MenuY();
            MMouse(MX - 10, MY - 10, 3, 3);
          end;
        end;
end;

(*
R_ChooseOptionMulti
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_ChooseOptionMulti(Options: TStringArray): Boolean;

Chooses the first option that is found in a tabbed or non-tabbed menu!

.. note::

  by Drags111

*)
function R_ChooseOptionMulti(Options: TStringArray): Boolean;
var
  X, Y, T: Integer;
begin
  Result := False;
  MarkTime(T);
  while not Client.MenuOpen() do
  begin
    if(TimeFromMark(T) > 500)then
      Exit;
    wait(50+Random(50));
  end;

  case Client.IsMenuTabbed() of
    true: Result := R_MMouseMenuTabbed(Options);
    false: Result := R_MMouseMenu(Options);
  end;

  if(Client.MenuOpen() and Result)then
  begin
    Result := False;
    GetMousePos(X, Y);
    Mouse(X, Y, 0, 0, True);
    MarkTime(T);
    while Client.MenuOpen() do
    begin
      if(TimeFromMark(T) > 3000)then
        Exit;
      wait(50+Random(50));
    end;
    Result := True;
  end;
end;

(*
R_ChooseOption
~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_ChooseOption(Option: String): Boolean;

Chooses the option if found in a tabbed or non-tabbed menu!

.. note::

  by Drags111

*)
function R_ChooseOption(Option: String): Boolean;
begin
  Result := R_ChooseOptionMulti([Option]);
end;

(*
R_OptionExistsMulti
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_OptionExistsMulti(Options: TStringArray): Boolean;

Returns true if one of the options in the Options array exists. Menu does
NOT have to be open for it to work.

.. note::

  by Drags111

*)
function R_OptionExistsMulti(Options: TStringArray): Boolean;
var
  MenuItems: TStringArray;
  MenuItemsTabbed: array of TStringArray;
  I, K, L: Integer;
begin
  Result := False;
  if(Client.MenuOptionCount() <= 0)then
    Exit;
  if(Client.IsMenuTabbed())then
  begin
    MenuItemsTabbed := R_GetMenuItemsTabbed;
    for I := 0 to High(MenuItemsTabbed)do
      for K := 0 to High(MenuItemsTabbed[I])do
        for L := 0 to High(Options)do
          if(Pos(Trim(Lowercase(Options[L])), MenuItemsTabbed[I][K]) > 0)then
          begin
            Result := True;
            Exit;
          end;
  end else
  begin
    MenuItems := R_GetMenuItems;
    for I := 0 to High(MenuItems)do
      for L := 0 to High(Options) do
        if(Pos(Trim(Lowercase(Options[L])), MenuItems[I]) > 0)then
        begin
          Result := True;
          Exit;
        end;
  end;
end;

(*
R_OptionExists
~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_OptionExists(Option: String): Boolean;

Returns true if the option exists. Menu does NOT have to be open for it to work.

.. note::

  by Drags111

*)
function R_OptionExists(Option: String): Boolean;
begin
  Result := R_OptionExistsMulti([Option]);
end;

(*
R_GetUpText
~~~~~~~~~~~

.. code-block:: pascal

    function R_GetUpText: string;

Gets the UpText (the text in the upper left corner of RS).

.. note::

  by Drags111

*)
function R_GetUpText: string;
var
  MenuItems: TStringArray;
  MenuItemsTabbed: array of TStringArray;
  First: String;
  MoreOptions, I, K: Integer;
begin
  case Client.IsMenuTabbed() of
    true: begin
      MenuItemsTabbed := R_GetMenuItemsTabbed;
      First := MenuItemsTabbed[0][0];
      for I := 0 to High(MenuItemsTabbed)do
        MoreOptions := MoreOptions + Length(MenuItemsTabbed[I]);
    end;
    false: begin
      MenuItems := R_GetMenuItems;
      First := MenuItems[0];
      for I := 0 to High(MenuItems)do
        Inc(MoreOptions);
    end;
  end;
  Result := Trim(Lowercase(First));

  try
    if(MoreOptions > 2) and (Result <> '')then
      Result := Result+' / '+inttostr(MoreOptions-2)+' more options';
  except
    R_Debug('Exception encountered.', 'R_GetUpText');
    Result := '';
  end;
end;

(*
R_IsUpTextMulti
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_IsUpTextMulti(UpText: TStringArray): Boolean;

Returns true if any instance of the UpText is found.

.. note::

  by Drags111

*)
function R_IsUpTextMulti(UpText: TStringArray): Boolean;
var
  I, T: integer;
  UT: String;
begin
  Result := False;
  MarkTime(T);
  while(UT = '')do
  begin
    UT := R_GetUpText;
    if(TimeFromMark(T) > 1000)then
      Exit;
    Wait(50+Random(50));
  end;
  for I := 0 to High(UpText) do
  begin
    Result := Pos(Trim(Lowercase(UpText[I])), UT) > 0;
    if Result then Exit;
  end;
end;

(*
R_IsUpText
~~~~~~~~~~

.. code-block:: pascal

    function R_IsUpText(UpText: string): Boolean;

Description: Returns true if UpText is found.

.. note::

  by Drags111

*)
function R_IsUpText(UpText: string): Boolean;
begin
  Result := R_IsUpTextMulti([UpText]);
end;

(*
R_WaitOptionMulti
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_WaitOptionMulti(S: TStringArray; Time: Integer): Boolean;

Waits to select an option, and if it finds it, selects it

.. note::

  by Naike

*)
function R_WaitOptionMulti(S: TStringArray; Time: Integer): Boolean;
var
  T: Integer;
begin
  Result := False;
  T := GetSystemTime + Time;
  while (GetSystemTime < T) do
  begin
    if R_ChooseOptionMulti(S) then
    begin
      Result := True;
      Exit;
    end;
    Wait(20 + Random(10));
  end;
end;

(*
R_WaitOption
~~~~~~~~~~~~

.. code-block:: pascal

    function R_WaitOption(S: String; Time: Integer): Boolean;

Waits to select an option, and if it finds it, selects it

.. note::

  by Naike

*)
function R_WaitOption(S: String; Time: Integer): Boolean;
begin
  Result := r_WaitOptionMulti([S], Time);
end;

(*
R_WaitUpTextMulti
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_WaitUpTextMulti(S: TStringArray; Time: Integer): Boolean;

Waits for an uptext in the UpText array.

.. note::

  by Naike

*)
function R_WaitUpTextMulti(S: TStringArray; Time: Integer): Boolean;
var
  T: Integer;
begin
  Result := False;
  T := GetSystemTime + Time;
  while (GetSystemTime < T) do
  begin
    if R_IsUpTextMulti(S) then
    begin
      Result := True;
      Exit;
    end;
    Wait(20 + Random(10));
  end;
end;

(*
R_WaitUpText
~~~~~~~~~~~~

.. code-block:: pascal

    function R_WaitUpText(S: String; Time: Integer): Boolean;

Waits for the UpText

.. note::

  by Naike

*)
function R_WaitUpText(S: String; Time: Integer): Boolean;
begin
  Result := r_WaitUpTextMulti([S], Time);
end;
