//------------------------------------------------------------------\\
//--               Simba Reflection Library                       --||
//--                   Objects Routines                           --||
//------------------------------------------------------------------//

//---                               Constants                               --//
{
const
  OBJ_INTERACTABLE    = 1;
  OBJ_WALLOBJECT      = 2;
  OBJ_WALLDECORATION  = 3;
  OBJ_FLOORDECORATION = 4;
}


//---                                Records                                --//



 {*******************************************************************************
function NULL_RSOBJECTEx: TRSObject;
Description: Nulls a TRSObject
*******************************************************************************}
function NULL_RSOBJECT: TRSObject;
begin
  Result.ID := NULL_INT;
  Result.ObjType := NULL_INT;
  Result.Tile := NULL_TILE;
  Result.TileArea := NULL_BOX;
end;

{*******************************************************************************
function R_NewObjectEx(ID, objType: integer; T: TTile; A: TBox): TRSObject;
By: Drags111
Description: Returns a new TRSObject with the specified values.
*******************************************************************************}
function R_NewObject(ID, ObjType: integer; Tile: TTile; TileArea: TBox): TRSObject;
begin
  Result.ID := ID;
  Result.ObjType := ObjType;
  Result.Tile := Tile;
  Result.TileArea := TileArea;
end;

{*******************************************************************************
function R_NewObjectDef(name: string; actions: TStringArray): TRSObjectDef;
By: pyroryan
Description: Returns a new TRSObject with the specified values.
*******************************************************************************}
function R_NewObjectDef(obj : TRSObject; objDef : Integer): TRSObjectDef;
var
  name : String;
  actions : TStringArray;
  javaString, actionsObj, actionsSize, count : Integer;
begin
  javaString := SmartGetFieldObject(objDef, hook_objectdef_getName);
  name := R_GetJavaString(javaString, 256);
  SmartFreeObject(javaString);

  actionsObj := SmartGetFieldObject(objDef, hook_objectdef_getActions);
  actionsSize := R_GetArraySize(actionsObj);
  SmartFreeObject(actionsObj);
  SetLength(actions, actionsSize);
  count := 0;
  while (count < actionsSize) do
  begin
    javaString := SmartGetFieldArrayObject(objDef, hook_objectdef_getActions, count);
    actions[count] := R_GetJavaString(javaString, 256);
    SmartFreeObject(javaString);
    count := count + 1;
  end;

  Result.name := name;
  Result.actions := actions;
end;

{*******************************************************************************
function R_ObjectInArray(theArray: TRSObjectArray; obj: TRSObject): boolean;
By: Drags111
Description: Returns true if an object obj is in a TRSObjectArray theArray.
              (like IntInArray).
*******************************************************************************}
function R_ObjectInArray(TheArray: TRSObjectArray; Obj: TRSObject): boolean;
var
  I: integer;
begin
  Result := False;
  for I := 0 to High(TheArray) do
    if(TheArray[I] = Obj)then
    begin
      Result := True;
      Exit;
    end;
end;

{*******************************************************************************
function R_GetObjectAt(T: TTile; objType: Integer): TRSObject;
By: Drags111
Description: Returns the object at the specified tile, with the type of objType.
*******************************************************************************}
function R_GetObjectAt(Tile: TTile; ObjType: Integer): TRSObject;
var
  Ground, Obj: integer;
begin
  Result := NULL_RSOBJECT;
  try
    Ground := RSObject_GetGroundAt(Tile);
    Obj := RSObject_GetObj(Ground, ObjType);
    Result := RSObject_GetBaseInfo(Obj, ObjType);
  finally
    R_FreeObjects([Ground, Obj]);
  end;
end;

{*******************************************************************************
function R_GetAllObjects(ObjType: Integer): TRSObjectArray;
By: Drags111
Description: Gets all loaded objects of the type, and stores them in a
            TRSObjectArray.
*******************************************************************************}
function R_GetAllObjects(ObjType: Integer): TRSObjectArray;
var
  bx, by, plane, Ground, x, y, resCount, obj: integer;
  Temp: TRSObject;
begin
  SetLength(Result, 104*104);
  resCount := 0;
  BX := Client.BaseX();
  BY := Client.BaseY();
  Plane := Client.LoadedPlane();
  for X := 0 to 103 do
    for Y := 0 to 103 do
    begin
      Ground := Client.GroundTiles(Plane, X, Y);
      Obj := RSObject_GetObj(Ground, ObjType);
      Temp := RSObject_GetBaseInfo(Obj, ObjType);
      if (Temp = NULL_RSOBJECT) then
      begin
        R_FreeObjects([Ground, Obj]);
        Continue;
      end;
      Result[resCount] := Temp;
      Inc(resCount);
      R_FreeObjects([Ground, Obj]);
    end;
  R_FreeObject(Plane);
  SetLength(Result, resCount);
end;

{*******************************************************************************
function R_SortedCircleTPA(Center: TPoint; Radius: Integer): TPointArray;
By: Wizzup and BenLand100
Description: Returns an array of all TPoints inside the circle. Sorted from
            closest to the Center.
*******************************************************************************}
function R_SortedCircleTPA(Center: TPoint; Radius: Integer): TPointArray;
begin
  SetLength(Result,0);
  Result := TPAFromBox(IntToBox(Center.X - Radius, Center.Y - Radius, Center.X + Radius, Center.Y + Radius));
  FilterPointsPie(Result, 0, 360, 0, Radius, Center.X, Center.Y);
  SortTPAFrom(Result, Center);
end;

{*******************************************************************************
function R_GetObjectsByIDEx(IDs: TIntegerArray; objType, MaxDist: Integer): TRSObjectArray;
By: mormonman
Description: Returns an array of all objects within the MaxDist with the IDs.
            Sorted from closest to the your player.
            MaxDist: This is the maximum distance from your player you wish to
                     search. The smaller the number, the faster the search is
                     completed. The maximum is 52.
*******************************************************************************}
function R_GetObjectsByIDEx(IDs: TIntegerArray; ObjType, MaxDist: Integer): TRSObjectArray;
var
   f, bx, by, resCount, Plane, Ground, Obj: Integer;
   MyPos: TTile;
   Temp: TRSObject;
   Tiles: TTileArray;
begin
  SetLength(Result, 104*104);
  resCount := 0;
  BX := Client.BaseX();
  BY := Client.BaseY();
  MyPos := R_GetMyPos;
  MyPos.X := MyPos.X - BX;
  MyPos.Y := MyPos.Y - BY;
  Tiles := R_SortedCircleTPA(MyPos, MaxDist);
  Plane := Client.LoadedPlane();
  if length(Tiles) < 1 then Exit;
  for f := 0 to High(Tiles) do
  begin
    Ground := Client.GroundTiles(Plane, Tiles[f].X, Tiles[f].Y);
    Obj := RSObject_GetObj(Ground, ObjType);
    Temp := RSObject_GetBaseInfo(Obj, ObjType);
    if (Temp = NULL_RSOBJECT) then
    begin
      R_FreeObjects([Ground, Obj]);
      Continue;
    end;
    if(InIntArray(IDs, Temp.ID) and (not R_ObjectInArray(Result, Temp)))then
    begin
      Result[resCount] := Temp;
      Inc(resCount);
    end;
    R_FreeObjects([Ground, Obj]);
  end;
  R_FreeObject(Plane);
  SetLength(Result, resCount);
end;

{*******************************************************************************
function R_GetObjectsByID(IDs: TIntegerArray; objType, MaxDist: Integer): TRSObjectArray;
By: mormonman
Description: Returns an array of all objects within the MaxDist with the ID.
            Sorted from closest to the your player.
            MaxDist: This is the maximum distance from your player you wish to
                     search. The smaller the number, the faster the search is
                     completed. The maximum is 52.
*******************************************************************************}
function R_GetObjectsByID(ID: Integer; objType, MaxDist: Integer): TRSObjectArray;
begin
  Result := R_GetObjectsByIDEx([ID], objType, MaxDist);
end;

{*******************************************************************************
function R_GetObjectByIDEx(IDs: TIntegerArray; objType, MaxDist: Integer): TRSObject;
By: mormonman
Description: Returns the closest object within the MaxDist with the IDs.
            MaxDist: This is the maximum distance from your player you wish to
                     search. The smaller the number, the faster the search is
                     completed. The maximum is 52.
*******************************************************************************}
function R_GetObjectByIDEx(IDs: TIntegerArray; objType, MaxDist: Integer): TRSObject;
var
   f: Integer;
   TP: TTile;
   TileObject: TRSObject;
   TPA: TPointArray;
begin
  Result := NULL_RSOBJECT;
  TP := R_GetMyPos;
  TPA := R_SortedCircleTPA(TP, MaxDist);
  if length(TPA) < 1 then Exit;
  for f := 0 to High(TPA) do
  begin
    TileObject := R_GetObjectAt(R_Tile(TPA[f].x, TPA[f].y), objType);
    if (not (TileObject = NULL_RSOBJECT) and InIntArray(IDs, TileObject.ID)) then
    begin
      Result := TileObject;
      Exit;
    end;
  end;
end;

{*******************************************************************************
function R_GetObjectByID(IDs: TIntegerArray; objType, MaxDist: Integer): TRSObject;
By: mormonman
Description: Returns the closest object within the MaxDist with the ID.
            MaxDist: This is the maximum distance from your player you wish to
                     search. The smaller the number, the faster the search is
                     completed. The maximum is 52.
*******************************************************************************}
function R_GetObjectByID(ID, objType, MaxDist: Integer): TRSObject;
begin
  Result := R_GetObjectByIDEx([ID], objType, MaxDist);
end;

{*******************************************************************************
function R_FindRSObject(Obj: TRSObject): Boolean;
By: Drags111
Description: Returns true if the TRSObject is found. All params must line up
            (Tile, objType, ID, and Area must all be the same).
*******************************************************************************}
function R_FindRSObject(Obj: TRSObject): Boolean;
var
  Temp: TRSObject;
begin
  Temp := R_GetObjectAt(Obj.Tile, Obj.objType);
  Result := (Obj = Temp);
end;

{*******************************************************************************
function R_FindRSObjectSimple(Obj: TRSObject): Boolean;
By: mormonman
Description: Returns true if the TRSObject is found.
            (Tile, objType, and ID must all be the same).
*******************************************************************************}
function R_FindRSObjectSimple(Obj: TRSObject): Boolean;
var
  Temp: TRSObject;
begin
  Temp := R_GetObjectAt(Obj.Tile, Obj.objType);
  Result := (Obj.ID = Temp.ID) and (Obj.objType = Temp.objType) and (Obj.Tile = Temp.Tile);
end;

{*******************************************************************************
function R_GetObjectDefinition(Obj: TRSObject): TRSObjectDef;
By: pyroryan
Description: Gets the object's definition
*******************************************************************************}
function R_GetObjectDefinition(Obj: TRSObject): TRSObjectDef;
var
  objDefLoader, mruNodes, nodeCache, node, hard, softref, soft : integer;
begin
  try
    objDefLoader := SmartGetFieldObject(0, hook_static_getObjectDefLoader);
    mruNodes := SmartGetFieldObject(objDefLoader, hook_objectdefloader_getMRUNodes);
    nodeCache := SmartGetFieldObject(mruNodes, hook_mrunodes_getNodeCache);
    SmartFreeObject(objDefLoader);
    SmartFreeObject(mruNodes);
    if (nodeCache = 0) then
      Exit;
    node := R_FindNodeByID(nodeCache, Obj.ID);
    SmartFreeObject(nodeCache);
    if (node = 0) then
      Exit;
    hard := SmartGetFieldObject(node, hook_hardreference_getObject); //"Field not Found" may occur
    if (hard <> 0) then
    begin
      Result := R_NewObjectDef(Obj, hard);
    end else
    begin
      softref := SmartGetFieldObject(node, hook_softreference_getReference);
      soft := SmartGetFieldObject(softref, 'referent');
      if (soft = 0) then
        Exit;
      Result := R_NewObjectDef(Obj, soft);
    end;
    SmartFreeObject(node);
  finally
    try
      SmartFreeObject(node);
    except
    end;
    try
      SmartFreeObject(hard);
    except
    end;
    try
      SmartFreeObject(softref);
    except
    end;
    try
      SmartFreeObject(soft);
    except
    end;
  end;
end;

{*******************************************************************************
function R_SortObjects(ObjArray : TRSObjectArray): TRSObjectArray;
By: Modded by Cstrike (Inherited from Widget and lordsaturn)
Description: Sorts Objects by distance from you.
*******************************************************************************}
function R_SortObjects(ObjArray : TRSObjectArray): TRSObjectArray;
var
  i, i2, L: integer;
  TPA: TPointArray;
begin
  L := GetArrayLength(ObjArray);
  if L < 1 then Exit;
  SetArrayLength(TPA, L);
  SetArrayLength(Result, L);
  for i := 0 to L - 1 do
    TPA[i] := ObjArray[i].Tile;
  SortTPAFrom(TPA, R_GetMyPos);
  for i := 0 to L - 1 do
    for i2 := 0 to L - 1 do
      if (TPA[i].x = ObjArray[i2].Tile.x) and (TPA[i].y = ObjArray[i2].Tile.y) then
        Result[i] := ObjArray[i2];
end;

procedure R_DumpObjects(ObjArray: TRSObjectArray);
var
  i: Integer;
begin
  for i := 0 to High(ObjArray) do
  begin
    WriteLn('Obj['+ToStr(i)+']:');
    WriteLn('   Type: ' + ToStr(ObjArray[i].objType));
    WriteLn('   ID: ' + ToStr(ObjArray[i].ID));
    WriteLn('   Tile: ' + ToStr(ObjArray[i].Tile));
    WriteLn('   Area: ' + ToStr(ObjArray[i].TileArea));
  end;
end;
