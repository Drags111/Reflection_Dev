{*
Players
=======

*}

{*******************************************************************************
function NULL_PLAYER: TRSPlayer;
Description: Nulls a TPlayer.
*******************************************************************************}
function NULL_PLAYER: TRSPlayer;
begin
  with Result do
  begin
    Tile := NULL_TILE;
    Name := NULL_STRING;
    Index := NULL_INT;
    Level := NULL_INT;
    Team := NULL_INT;
    Height := NULL_INT;
    Animation := NULL_INT;
    Motion := NULL_INT;
    HPRatio := NULL_INT;
    InCombat := False;
    WalkQueueX := NULL_INT;
    WalkQueueY := NULL_INT;
    Interacting := NULL_INT;
    Orientation := NULL_INT;
  end;
end;

{*******************************************************************************
function R_GetAnimation: Integer;
By: drags111
Description: Returns your player's animation.
*******************************************************************************}
function R_GetAnimation: Integer;
var
  MyPlayer: Integer;
begin
  MyPlayer := Client.MyPlayer();
  Result := RSCharacter_GetAnimation(MyPlayer);
  R_FreeObject(MyPlayer);
end;

{*******************************************************************************
function R_GetSpeed: Integer;
By: drags111
Description: Returns your player's speed. (0 = not moving. > 0 = moving.)
*******************************************************************************}
function R_GetSpeed: Integer;
var
  MyPlayer: Integer;
begin
  MyPlayer := Client.MyPlayer();
  Result := RSCharacter_GetMotion(MyPlayer);
  R_FreeObject(MyPlayer);
end;

{*******************************************************************************
function R_IsIdle: Boolean;
By: lordsaturn
Description: Returns true if your player is idle. (no movement or animation)
*******************************************************************************}
function R_IsIdle: Boolean;
begin
  Result := (R_GetAnimation = -1) and (R_GetSpeed = 0);
end;

{*******************************************************************************
function R_Moving: Boolean;
By: lordsaturn
Description: Returns true if your player is moving.
*******************************************************************************}
function R_Moving: Boolean;
begin
  Result := (R_GetSpeed > 0);
end;

{*******************************************************************************
function R_Animating: Boolean;
By: lordsaturn
Description: Returns true if your player is animating.
*******************************************************************************}
function R_Animating: Boolean;
begin
  Result := (R_GetAnimation > -1);
end;

{*******************************************************************************
function R_InCombat: Boolean;
By: drags111
Description: Returns true if your player is in combat.
*******************************************************************************}
function R_InCombat: Boolean;
var
  MyPlayer: Integer;
begin
  MyPlayer := Client.MyPlayer();
  Result := RSCharacter_GetInCombat(MyPlayer);
  R_FreeObject(MyPlayer);
end;

{*******************************************************************************
function R_WaitForAnimation(Timeout: Integer): Boolean;
By: drags111
Description: Waits until your character animates, or the timeout is reached.
*******************************************************************************}
function R_WaitForAnimation(Timeout: Integer): Boolean;
var
  T: Integer;
begin
  MarkTime(T);
  while (R_GetAnimation = -1) do
  begin
    if (TimeFromMark(T) >= Timeout) then
      Exit;
    Wait(50 + Random(50));
  end;
  Result := True;
end;

{*******************************************************************************
function R_SortPlayers(Players: TRSPlayerArray): TRSPlayerArray;
By: lordsaturn
Description: Sorts players by distance from you.
*******************************************************************************}
function R_SortPlayers(Players: TRSPlayerArray): TRSPlayerArray;
var
  I, K: integer;
  TPA: TPointArray;
begin
  if (High(Players) < 0) then Exit;
  SetArrayLength(TPA, High(Players) + 1);
  SetArrayLength(Result, High(Players) + 1);
  for I := 0 to High(Players) do TPA[I] := Players[I].Tile;
  SortTPAFrom(TPA, R_GetMyPos);
  for I := 0 to High(Players) do
    for K := 0 to High(Players) do
      if(TPA[I].x = Players[K].Tile.x) and (TPA[I].y = Players[K].Tile.y)then
        Result[I] := Players[K];
end;

{*******************************************************************************
function R_GetAllPlayers: TRSPlayerArray;
By: drags111
Description: Returns all the players on the minimap.
*******************************************************************************}
function R_GetAllPlayers: TRSPlayerArray;
var
  I, Count, IndexPos, Player: integer;
begin
  Count := Client.PlayerCount();
  SetArrayLength(Result, Count);
  if Count < 1 then Exit;
  for I := 0 to Count-1 do
  try
    IndexPos := Client.PlayerIndexArray(I);
    Player := Client.Players(IndexPos);
    Result[I].Index := IndexPos;
    Result[I] := RSPlayer_GetBaseInfo(Player);
  finally
    R_FreeObject(Player);
  end;
end;

{*******************************************************************************
function R_GetPlayersMulti(TheVarArr: TVariantArray): TRSPlayerArray;
By: drags111, mormonman
Description: Returns all the players by the variants. (Names or Indexes)
*******************************************************************************}
function R_GetPlayersMulti(TheVarArr: TVariantArray): TRSPlayerArray;
var
  vType, I, H, resCounter: Integer;
  Players: TRSPlayerArray;
  B: Boolean;
begin
  Players := R_SortPlayers(R_GetAllPlayers);
  SetLength(Result, Length(Players));
  for I := 0 to High(Players) do
    for H := 0 to High(TheVarArr) do
    begin
      vType := VarType(TheVarArr[H]);
      if (vType = varString) then TheVarArr[H] := LowerCase(Trim(TheVarArr[H]));
      case vType of
        varInteger: B := Players[I].Index = TheVarArr[H];
        varString: B := (Pos(TheVarArr[H], LowerCase(Trim(Players[I].Name))) > 0);
        else Exit;
      end;
      if not b then Continue;
      Result[resCounter] := Players[I];
      Inc(resCounter);
    end;
  SetLength(Result, resCounter);
end;

{*******************************************************************************
function R_GetPlayers(TheVar: Variant): TRSPlayerArray;
By: drags111, mormonman
Description: Returns all the players by the variant. (Name or Index)
*******************************************************************************}
function R_GetPlayers(TheVar: Variant): TRSPlayerArray;
begin
  Result := R_GetPlayersMulti([TheVar]);
end;

{*******************************************************************************
function R_GetPlayerMulti(TheVarArr: TVariantArray): TRSPlayer;
By: drags111, mormonman
Description: Gets the closest player that matches the arguments.
*******************************************************************************}
function R_GetPlayerMulti(TheVarArr: TVariantArray): TRSPlayer;
var
  Players: TRSPlayerArray;
  I, H, vType: Integer;
  B: Boolean;
begin
  Result := NULL_PLAYER;
  Players := R_SortPlayers(R_GetAllPlayers);
  for I := 0 to High(Players) do
    for h := 0 to High(TheVarArr) do
    begin
      vType := VarType(TheVarArr[H]);
      if (vType = varString) then TheVarArr[H] := LowerCase(TheVarArr[H]);
      case (vType) of
        varInteger: B := Players[I].Index = TheVarArr[H];
        varString: B := (Pos(TheVarArr[H], LowerCase(Players[I].Name)) > 0);
        else Continue;
      end;
      if b then
      begin
        Result := Players[I];
        Exit;
      end;
    end;
end;

{*******************************************************************************
function R_GetPlayer(TheVar: Variant): TRSPlayer;
By: drags111, mormonman
Description: Gets the closest player that matches the argument.
*******************************************************************************}
function R_GetPlayer(TheVar: Variant): TRSPlayer;
begin
  Result := R_GetPlayerMulti([TheVar]);
end;

{*******************************************************************************
function R_GetPlayersByLevelEx(Levels: TIntegerArray): TRSPlayerArray;
By: mormonman
Description: Returns all players with the defined levels.
  *Note - Levels = Combat Levels
*******************************************************************************}
function R_GetPlayersByLevelEx(Levels: TIntegerArray): TRSPlayerArray;
var
  I, H, Counter: Integer;
  Players: TRSPlayerArray;
begin
  Players := R_SortPlayers(R_GetAllPlayers);
  SetLength(Result, Length(Players));
  for I := 0 to High(Players) do
    for H := 0 to High(Levels) do
      if Players[I].Level = Levels[H] then
      begin
        Result[Counter] := Players[I];
        Inc(Counter);
      end;
  SetLength(Result, Counter);
end;

{*******************************************************************************
function R_GetPlayersByLevel(Level: Integer): TRSPlayerArray;
By: mormonman
Description: Returns all players with the defined level.
*******************************************************************************}
function R_GetPlayersByLevel(Level: Integer): TRSPlayerArray;
begin
  Result := R_GetPlayersByLevelEx([Level]);
end;

{*******************************************************************************
function R_GetPlayerByLevelEx(Levels: TIntegerArray): TRSPlayer;
By: mormonman/drags111
Description: Gets the closest player that is one of the levels.
*******************************************************************************}
function R_GetPlayerByLevelEx(Levels: TIntegerArray): TRSPlayer;
var
  I, H: Integer;
  Players: TRSPlayerArray;
begin
  Result := NULL_PLAYER;
  Players := R_SortPlayers(R_GetAllPlayers);
  for I := 0 to High(Players) do
    for H := 0 to High(Levels) do
      if Players[I].Level = Levels[H] then
      begin
        Result := Players[i];
        Exit;
      end;
end;

{*******************************************************************************
function R_GetPlayerByLevel(Level: Integer): TRSPlayer;
By: mormonman
Description: Gets the closest player that is the level.
*******************************************************************************}
function R_GetPlayerByLevel(Level: Integer): TRSPlayer;
begin
  Result := R_GetPlayerByLevelEx([Level]);
end;

{*******************************************************************************
function R_GetMe: TRSPlayer;
By: drags111
Description: Returns you.
*******************************************************************************}
function R_GetMe: TRSPlayer;
var
  Player: Integer;
begin
  try
    Player := Client.MyPlayer();
    Result := RSPlayer_GetBaseInfo(Player);
  finally
    R_FreeObject(Player);
  end;
end;

{*******************************************************************************
function R_InteractingWithMe(NPC: TNPC): Boolean;
By: drags111
Description: Checks if the NPC is currently interacting with your character.
*******************************************************************************}
function R_InteractingWithMe(NPC: TNPC): Boolean;
var
  Me, Player: TRSPlayer;
  PlayerIndex: integer;
begin
  NPC := R_GetNPC(NPC.ID);
  Me := R_GetMe;
  PlayerIndex := (NPC.Interacting - 32768);
  Player := R_GetPlayer(PlayerIndex);
  Result := (Player.Name = Me.Name);
end;

{*******************************************************************************
function R_AreWeInteracting(var NPC: TNPC): Boolean;
By: mormonman
Description: Returns true if we are interacting. If we are, then it returns npc
we are interacting with.
*******************************************************************************}
function R_AreWeInteracting(var NPC: TNPC): Boolean;
var
  I, Index: Integer;
  NPCs: TNPCArray;
  Me, Player: TRSPlayer;
begin
  NPC := NULL_NPC;
  Me := R_GetMe;
  NPCs := R_GetAllNPCs(False);
    for I := 0 to High(NPCs) do
    begin
      Index := NPCS[I].Interacting - 32768;
      if (Index > 0) then
      begin
        Player := R_GetPlayer(Index);
        Result := Player.Name = Me.Name;
        if Result then
        begin
          NPC := NPCs[I];
          Exit;
        end;
      end;
    end;
end;

procedure R_DumpPlayers(Players: TRSPlayerArray);
var
  I: Integer;
begin
  for I := 0 to High(Players) do
    with Players[I] do
    begin
      Writeln('Player: ' + Name);
      Writeln('    Tile: ' + ToStr(Tile));
      Writeln('    Index: ' + ToStr(Index));
      Writeln('    Combat Level: ' + ToStr(Level));
      Writeln('    Team: ' + ToStr(Team));
      Writeln('    Height: ' + ToStr(Height));
      Writeln('    Animation: ' + ToStr(Animation));
      Writeln('    Motion: ' + ToStr(Motion));
      Writeln('    HPRatio: ' + ToStr(HPRatio));
      Writeln('    InCombat: ' + ToStr(InCombat));
      Writeln('    WalkQueueX: ' + ToStr(WalkQueueX));
      Writeln('    WalkQueueY: ' + ToStr(WalkQueueY));
      Writeln('    Interacting: ' + ToStr(Interacting));
      Writeln('    Orientation: ' + ToStr(Orientation));
    end;
end;
